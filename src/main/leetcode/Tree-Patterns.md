### Tree Patterns


#### Ancestor problem:
  1)  https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/
  2)  https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/
  3)  https://leetcode.com/problems/maximum-difference-between-node-and-ancestor/
  4)  https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/
  5)  https://leetcode.com/problems/kth-ancestor-of-a-tree-node/ 
  6)  https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/

#### Root to leaf path problems:
  7)  https://leetcode.com/problems/binary-tree-paths/ EASY
  8)  https://leetcode.com/problems/path-sum-iii/submissions/
  9)  https://leetcode.com/problems/smallest-string-starting-from-leaf/
  10) https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/
  11) https://leetcode.com/problems/insufficient-nodes-in-root-to-leaf-paths/
  12) https://leetcode.com/problems/pseudo-palindromic-paths-in-a-binary-tree/ 

#### Serialize and deserialize:
  13) https://leetcode.com/problems/serialize-and-deserialize-binary-tree/ 
  14) https://leetcode.com/problems/verify-preorder-serialization-of-a-binary-tree/
  15) https://leetcode.com/problems/serialize-and-deserialize-bst/
  
#### Leaves related problem:
  16) https://leetcode.com/problems/sum-of-left-leaves/
  17) https://leetcode.com/problems/leaf-similar-trees/
  18) https://leetcode.com/problems/deepest-leaves-sum/
  19) https://leetcode.com/problems/delete-leaves-with-a-given-value/

#### Level order traversal:
  20) https://leetcode.com/problems/smallest-subtree-with-all-the-deepest-nodes/
  21) https://leetcode.com/problems/path-in-zigzag-labelled-binary-tree/
  22) https://leetcode.com/problems/maximum-level-sum-of-a-binary-tree/
  23) https://leetcode.com/problems/sum-of-nodes-with-even-valued-grandparent/
  24) https://leetcode.com/problems/frog-position-after-t-seconds/
  25) https://leetcode.com/problems/even-odd-tree/
  26) https://leetcode.com/problems/binary-tree-level-order-traversal/
  27) https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/
  28) https://leetcode.com/problems/binary-tree-level-order-traversal-ii/
  29) https://leetcode.com/problems/binary-tree-right-side-view/
  30) https://leetcode.com/problems/n-ary-tree-level-order-traversal/
  31) https://leetcode.com/problems/find-largest-value-in-each-tree-row/
  32) https://leetcode.com/problems/add-one-row-to-tree/
  33) https://leetcode.com/problems/average-of-levels-in-binary-tree/
  34) https://leetcode.com/problems/maximum-width-of-binary-tree/
  
#### Node deletion:
  35) https://leetcode.com/problems/delete-nodes-and-return-forest/
  36) https://leetcode.com/problems/delete-node-in-a-bst/

#### Tree construction:
  37) https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/
  38) https://leetcode.com/problems/all-possible-full-binary-trees/
  39) https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/
  40) https://leetcode.com/problems/recover-a-tree-from-preorder-traversal/
  41) https://leetcode.com/problems/validate-binary-tree-nodes/
  42) https://leetcode.com/problems/number-of-ways-to-reconstruct-a-tree/
  43) https://leetcode.com/problems/merge-bsts-to-create-single-bst/
  44) https://leetcode.com/problems/unique-binary-search-trees-ii/
  45) https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/
  46) https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/
  
#### Distance between two Nodes: 
  47) https://leetcode.com/problems/minimum-distance-between-bst-nodes/
  48) https://leetcode.com/problems/sum-of-distances-in-tree/ 
  49) https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/

#### Inorder traversal:
  50) https://leetcode.com/problems/increasing-order-search-tree/
  51) https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/
  52) https://leetcode.com/problems/all-elements-in-two-binary-search-trees/
  53) https://leetcode.com/problems/validate-binary-search-tree/
  54) https://leetcode.com/problems/convert-bst-to-greater-tree/

#### Rangesum of BT:
  55) https://leetcode.com/problems/range-sum-of-bst/

#### Flipping:
  56) https://leetcode.com/problems/flip-equivalent-binary-trees/
  57) https://leetcode.com/problems/flip-binary-tree-to-match-preorder-traversal/
 
#### Check binary tree:
  58) https://leetcode.com/problems/check-completeness-of-a-binary-tree/
  59) https://leetcode.com/problems/univalued-binary-tree/
  
#### Tree relations:
  60) https://leetcode.com/problems/cousins-in-binary-tree/

#### Counting of nodes:
  61) https://leetcode.com/problems/count-good-nodes-in-binary-tree/
  62) https://leetcode.com/problems/number-of-nodes-in-the-sub-tree-with-the-same-label/
  63) https://leetcode.com/problems/number-of-good-leaf-nodes-pairs/
  
#### Recovery:
  64) https://leetcode.com/problems/recover-binary-search-tree/

#### Kth smallest :
  65) https://leetcode.com/problems/kth-smallest-element-in-a-bst/
  66) https://leetcode.com/problems/kth-largest-element-in-a-stream/
  
#### Trimming or pruning:
  67) https://leetcode.com/problems/trim-a-binary-search-tree/
  
#### Searching:
  68) https://leetcode.com/problems/search-in-a-binary-search-tree/
  
#### Difference problem in BT:
  69) https://leetcode.com/problems/kth-largest-element-in-a-stream/
  
#### Tree checking:
  70) https://leetcode.com/problems/same-tree/
  71) https://leetcode.com/problems/symmetric-tree/
  72) https://leetcode.com/problems/subtree-of-another-tree/
  
#### Depth problem:
  73) https://leetcode.com/problems/maximum-depth-of-binary-tree/
  74) https://leetcode.com/problems/minimum-depth-of-binary-tree/
  75) https://leetcode.com/problems/minimum-absolute-difference-in-bst/
  76) https://leetcode.com/problems/maximum-depth-of-n-ary-tree/
  77) https://leetcode.com/problems/largest-bst-subtree/
  78) https://leetcode.com/problems/find-duplicate-subtrees/

## Ancestor problem:
https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/
```
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == null) return root;
        
        TreeNode node = root;
        
        while(node != null) {
            if(node.val < p.val && node.val < q.val) {
                node = node.right;
            } else if(node.val > p.val && node.val > q.val){
                node = node.left;
            } else {
                return node;
            }
        }
        return node;
    }
```
https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/
```
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == null) return root;
        
        Deque<TreeNode> stack = new ArrayDeque<>();
        
        Map<TreeNode, TreeNode> dict = new HashMap<>();
        stack.add(root);
        dict.put(root, null);
        
        while(!dict.containsKey(p) || !dict.containsKey(q)) {
            TreeNode node = stack.pop();
            
            if(node.left != null) {
                dict.put(node.left, node);
                stack.push(node.left);
            }
            
            if(node.right != null) {
                dict.put(node.right, node);
                stack.push(node.right);
            }
        }
        
        Set<TreeNode> ancestors = new HashSet<>();
        
        while(p != null) {
            ancestors.add(p);
            p = dict.get(p);
        }
        
        while(!ancestors.contains(q)) {
            q = dict.get(q);
        }
        return q;
    }
```
https://leetcode.com/problems/maximum-difference-between-node-and-ancestor/
```
    int result = 0;
    public int maxAncestorDiff(TreeNode root) {
        if(root == null) return 0;
        
        helper(root, root.val, root.val);
        
        return result;
    }
    
    public void helper(TreeNode node, int curMax, int curMin) {
        if(node == null) return;
        
        int possibleResult = Math.max(Math.abs(curMax - node.val), Math.abs(curMin - node.val));
        
        result = Math.max(result, possibleResult);
        
        curMax = Math.max(curMax, node.val);
        curMin = Math.min(curMin, node.val);
        helper(node.left, curMax, curMin);
        helper(node.right, curMax, curMin);
        return;
    }
```
https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/
```
    public TreeNode lcaDeepestLeaves(TreeNode root) {
        if(root == null) return root;
        
        int left = height(root.left);
        int right = height(root.right);
        if(left == right) {
            return root;
        } else if(left > right) {
            return lcaDeepestLeaves(root.left);
        } else {
            return lcaDeepestLeaves(root.right);
        }
    }
    
    public int height(TreeNode node) {
        if(node == null) return 0;
        
        return Math.max(height(node.left), height(node.right)) + 1;
    }
```
https://leetcode.com/problems/kth-ancestor-of-a-tree-node/
https://leetcode.com/problems/kth-ancestor-of-a-tree-node/discuss/1298231/Java-Simple-Solution-using-Binary-Lifting
```
int jump[][];
    
    public TreeAncestor(int n, int[] parent) {
        // log_base_2(n)
        int maxPow = (int) (Math.log(n) / Math.log(2)) + 1;
        jump = new int[maxPow][n];
        jump[0] = parent;
        for (int p = 1; p < maxPow; p++) {
            for (int j = 0; j < n; j++) {
                int pre = jump[p - 1][j];
                jump[p][j] = pre == -1 ? -1 : jump[p - 1][pre];
            }
        }
    }
    
    public int getKthAncestor(int node, int k) {
        int row = 0;
        while(k > 0) {
            if((k & 1) == 1) {
                if(node == -1) return -1;
                node = jump[row][node];
            }
            k >>= 1;
            row++;
        }
        return node;
    }
```
#### Root to leaf path problems:

https://leetcode.com/problems/binary-tree-paths/
iterative using two stacks, node_stack and path_stack
```
public List<String> binaryTreePaths(TreeNode root) {
        List<String> res = new ArrayList<>();
        rootToLeaf(root, "", res);
        return res;
    }
    
    public void rootToLeaf(TreeNode root, String path, List<String> paths) {
        if(root != null) {
            path += Integer.toString(root.val);
            if(root.left == null && root.right == null) {
                paths.add(path);
            } else {
                path += "->";
                rootToLeaf(root.left, path, paths);
                rootToLeaf(root.right, path, paths);
            }
        }
    }
```
https://leetcode.com/problems/path-sum-iii/
```
int count = 0;
    public int pathSum(TreeNode root, int targetSum) {
        helper(root, 0, targetSum, new HashMap<Integer, Integer>());
        return count;
    }
    
    public void helper(TreeNode root, int curSum, int target, Map<Integer, Integer> dict) {
        if(root == null) return;
        
        curSum += root.val;
        
        if(curSum == target) {
            count++;
        }
        
        if(dict.containsKey(curSum - target)) {
            count += dict.get(curSum - target);
        }
        
        dict.put(curSum, dict.getOrDefault(curSum, 0) + 1);
        
        helper(root.left, curSum, target, dict);
        helper(root.right, curSum, target, dict);
        
        dict.put(curSum, dict.getOrDefault(curSum, 0) - 1);
    }
```
https://leetcode.com/problems/smallest-string-starting-from-leaf/
```
String ans = "~";
    public String smallestFromLeaf(TreeNode root) {
        helper(root, new StringBuilder());
        return ans;
    }
    
    public void helper(TreeNode root, StringBuilder sb) {
        if(root == null) return;
        
        sb.append((char)('a' + root.val));
        
        if(root.left == null && root.right == null) {
            sb.reverse();
            String s = sb.toString();
            sb.reverse();
            
            if(s.compareTo(ans) < 0) {
                ans = s;
            }
        }
        
        helper(root.left, sb);
        helper(root.right, sb);
        sb.deleteCharAt(sb.length() - 1);
    }
    
```
https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/
```
    public int sumRootToLeaf(TreeNode root) {
        if(root == null) return 0;
        Deque<Pair<TreeNode, Integer>> stack = new ArrayDeque<>();
        stack.add(new Pair(root, 0));
        int rootToLeafSum = 0;
        
        while(!stack.isEmpty()) {
            Pair<TreeNode, Integer> p = stack.poll();
            TreeNode node = p.getKey();
            int curNum = p.getValue();
            
            if(root != null) {
                curNum = (curNum << 1) | node.val;
                
                if(node.left ==  null && node.right == null) {
                    rootToLeafSum += curNum;
                }
                if(node.left != null) {
                    stack.add(new Pair(node.left, curNum));
                }
                if(node.right != null) {
                    stack.add(new Pair(node.right, curNum));
                }
            }
        }
        return rootToLeafSum;
    }
```
https://leetcode.com/problems/insufficient-nodes-in-root-to-leaf-paths/
```
    public TreeNode sufficientSubset(TreeNode root, int limit) {
        if(root == null) return root;
        
        if(root.left == null && root.right == null) {
            return root.val < limit ? null : root;
        }
        root.left = sufficientSubset(root.left, limit - root.val);
        root.right = sufficientSubset(root.right, limit - root.val);
        return root.left == null && root.right == null ? null : root;
    }
```
https://leetcode.com/problems/pseudo-palindromic-paths-in-a-binary-tree/
```
int result  = 0;
    int[] digits;
    public int pseudoPalindromicPaths (TreeNode root) {
        digits = new int[10];
        helper(root);
        return result;
    }
    
    public void helper(TreeNode root) {
        if(root == null) return;
        
        digits[root.val]++;
        if(root.left == null && root.right == null) {
            if(isPalindome()){
                result++;
            }
        } else {
            helper(root.left);
            helper(root.right);
        }
        digits[root.val]--;
    }
    
    public boolean isPalindome() {
        int odd = 0;
        for(int i = 1; i <= 9 ; i++) {
            if(digits[i]  % 2 != 0) {
                odd++;
            }
        }
        return odd > 1 ? false : true;
     }
```

#### Serialize and deserialize:

https://leetcode.com/problems/serialize-and-deserialize-binary-tree/
```
 public StringBuilder rserialize(TreeNode root, StringBuilder res) {
        if(root == null) {
            res.append("null,");
        } else {
            res.append(root.val + ",");
            rserialize(root.left, res);
            rserialize(root.right, res);
        }
        return res;
    }
    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        return rserialize(root, new StringBuilder()).toString();
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        String[] list = data.split(",");
        return rdeserialize(new ArrayList<>(Arrays.asList(list)));
    }
    public TreeNode rdeserialize(List<String> list) {
        if(list.get(0).equals("null")) {
            list.remove(0);
            return null;
        }
        
        TreeNode root = new TreeNode(Integer.valueOf(list.get(0)));
        list.remove(0);
        root.left = rdeserialize(list);
        root.right = rdeserialize(list);
        return root;
    }
```
https://leetcode.com/problems/verify-preorder-serialization-of-a-binary-tree/

```
    public boolean isValidSerialization(String preorder) {
        int slots = 1;
        
        for(int i = 0; i < preorder.length(); i++) {
            if(preorder.charAt(i) == ',') {
                slots--;
                
                if(slots < 0) return false;
                
                if(preorder.charAt(i - 1) != '#') {
                    slots += 2;
                }
            }
        }
        
        slots = (preorder.charAt(preorder.length() - 1) == '#') ? slots - 1: slots + 1;
        return slots == 0;
    }
```
https://leetcode.com/problems/serialize-and-deserialize-bst/
```
public StringBuilder binarySerialize(TreeNode root, StringBuilder sb) {
        if(root == null) return sb;
        binarySerialize(root.left, sb);
        binarySerialize(root.right, sb);
        sb.append(root.val);
        sb.append('#');
        return sb;
    }
    
    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        StringBuilder sb = binarySerialize(root, new StringBuilder());
        if(sb.length() > 0) 
            sb.deleteCharAt(sb.length() - 1);
        return sb.toString();
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        if(data.isEmpty()) return null;
        
        Deque<Integer> stack = new ArrayDeque<>();
        for(String s : data.split("#")) {
            stack.add(Integer.valueOf(s));
        }
        return binaryDeserialize(Integer.MIN_VALUE, Integer.MAX_VALUE, stack);
    }
    
    public TreeNode binaryDeserialize(int min, int max, Deque<Integer> stack) {
        if(stack.isEmpty()) return null;
        
        int val = stack.getLast();
        if(val < min || val > max) return null;
        
        stack.removeLast();
            
        TreeNode root = new TreeNode(val);
        root.right = binaryDeserialize(val, max, stack);
        root.left = binaryDeserialize(min, val, stack);
        return root;
    }
```
#### Leaves related problem:
https://leetcode.com/problems/sum-of-left-leaves/
```
public boolean isLeaf(TreeNode root) {
        return root != null && root.left == null && root.right == null;
    }
    
    public int sumOfLeftLeaves(TreeNode root) {
        if(root == null) return 0;
        
        int res = 0;
        
        Deque<TreeNode> stack = new ArrayDeque<>();
        stack.add(root);
        
        while(!stack.isEmpty()) {
            TreeNode node = stack.pop();
            if(isLeaf(node.left)) {
                res += node.left.val;
            }
            
            if(node.left != null) {
                stack.add(node.left);
            }
            if(node.right != null) {
                stack.add(node.right);
            }
        }
        return res;
    }
```

https://leetcode.com/problems/leaf-similar-trees/
```
public String leafString(TreeNode node) {
        if(node == null) return null;
        
        StringBuilder  sb = new StringBuilder();
        
        Stack<TreeNode> s = new Stack();
        
        s.add(node);
        
        while(!s.isEmpty()) {
            TreeNode root = s.pop();
            if(root.left == null && root.right == null) {
                sb.append(root.val);
            }
            
            if(root.left != null) {
                s.add(root.left);
            }
            
            if(root.right != null) {
                s.add(root.right);
            }
        }
        return sb.toString();
        
    }
    public boolean leafSimilar(TreeNode root1, TreeNode root2) {
        if(root1 == null || root2 == null) return false;
        
        String string1 = leafString(root1);
        String string2 = leafString(root2);
        return string1.equals(string2);
    }
```
https://leetcode.com/problems/deepest-leaves-sum/
```
public int deepestLeavesSum(TreeNode root) {
        if(root == null) return 0;
        
        Deque<Pair<TreeNode, Integer>>  q = new ArrayDeque<>();
        q.add(new Pair(root, 0));
        int depth = 0, curDepth = 0, sum = 0;
        
        while(!q.isEmpty()) {
            Pair<TreeNode, Integer> p = q.poll();
            TreeNode node = p.getKey();
            curDepth = p.getValue();
            
            if(node.left == null && node.right == null) {
                if(depth < curDepth) {
                    depth = curDepth;
                    sum = node.val;
                } else if(depth == curDepth) {
                    sum += node.val;
                }
            } else {
                if(node.left != null) {
                    q.add(new Pair(node.left, curDepth + 1));
                }
                
                if(node.right != null) {
                    q.add(new Pair(node.right, curDepth + 1));
                }
            }
            
        }
        return sum;
    }
```
https://leetcode.com/problems/delete-leaves-with-a-given-value/
```
public TreeNode removeLeafNodes(TreeNode root, int target) {
        if(root == null) return root;

        TreeNode left = removeLeafNodes(root.left, target);
        TreeNode right = removeLeafNodes(root.right, target);
        if(left == null && right == null && root.val == target) {
            return null;
        }
        
        root.left = left;
        root.right = right;
        
        return root;
    }
```


#### Level order traversal:
https://leetcode.com/problems/smallest-subtree-with-all-the-deepest-nodes/
```
Map<TreeNode, Integer> depthDict;
    int maxDepth;
    public TreeNode subtreeWithAllDeepest(TreeNode root) {
        depthDict = new HashMap<>();
        depthDict.put(null, -1);
        dfs(root, null);
        
        for(int max : depthDict.values()) {
            maxDepth = Math.max(maxDepth, max);
        }
        
        return answer(root);
    }
    
    public void dfs(TreeNode node, TreeNode parent) {
        if (node != null) {
            depthDict.put(node, depthDict.get(parent) + 1);
            dfs(node.left, node);
            dfs(node.right, node);
        }
    }
    
    public TreeNode answer(TreeNode root) {
        if(root == null || depthDict.get(root) == maxDepth) {
            return root;
        }
        TreeNode left = answer(root.left), right = answer(root.right);
        
        if(left != null && right != null) return root;
        if(left == null) return right;
        if(right == null) return left;
        return null;
    }
```
https://leetcode.com/problems/path-in-zigzag-labelled-binary-tree/
```
    public List<Integer> pathInZigZagTree(int label) {
        List<Integer> res = new ArrayList<>();
        if(label <= 0) return res;
        int level = 0;
        // find the level, by getting number of nodes at give label.
        while(Math.pow(2, level) - 1 < label) level++;
        level--;
        
        while(level != 0) {
            res.add(0, label);
            // find the position on next label
            int pos = label - (int)Math.pow(2, level);
            // find the next label
            label = label - (pos + 1) - pos / 2;
            level--;
        }
        res.add(0, 1);
        return res;
    }
```
https://leetcode.com/problems/maximum-level-sum-of-a-binary-tree/
```
public int maxLevelSum(TreeNode root) {
        if(root == null) return 0;
        int maxSum = Integer.MIN_VALUE;
        
        Queue<TreeNode> q = new LinkedList<>();
        q.add(root);
        int level = 0, maxLevel = 0;
        while(!q.isEmpty()) {
            int size = q.size();
            
            int curSum = 0;
            level++;
            for(int i = 0; i < size; i++) {
                TreeNode node = q.poll();
                
                curSum += node.val;
                
                if(node.left != null) {
                    q.add(node.left);
                }
                
                if(node.right != null) {
                    q.add(node.right);
                }
            }
            if(maxSum < curSum) {
                maxLevel = level;
                maxSum = curSum;
            }
        }
        return maxLevel;
    }
```
https://leetcode.com/problems/sum-of-nodes-with-even-valued-grandparent/
```
public int sumEvenGrandparent(TreeNode root) {
        if(root == null) return 0;
        
        
        Queue<TreeNode> q = new LinkedList<>();
        q.add(root);
        
        int sum = 0;
        
        while(!q.isEmpty()){
            TreeNode node = q.poll();
            
            if(node.left != null) {
                q.add(node.left);
                if(node.val % 2 == 0) {
                    if(node.left.left != null) {
                        sum += node.left.left.val;
                    }
                    
                    if(node.left.right != null) {
                        sum += node.left.right.val;
                    }
                }
            }
            
           if(node.right != null) {
                q.add(node.right);
                if(node.val % 2 == 0) {
                    if(node.right.left != null) {
                        sum += node.right.left.val;
                    }
                    
                    if(node.right.right != null) {
                        sum += node.right.right.val;
                    }
                }
            }
        }
        return sum;
        
    }
```
https://leetcode.com/problems/frog-position-after-t-seconds/
```
class Pair {
        int node;
        int time;
        double prob;
        public Pair(int node, int time, double prob) {
            this.node = node;
            this.time = time;
            this.prob = prob;
        }
    }
    public double frogPosition(int n, int[][] edges, int t, int target) {
        List<Integer>[] tree = new ArrayList[n + 1];
        for(int i = 0; i <= n; i++){
            tree[i] = new ArrayList<>();
        }
        for(int[] edge: edges) {
            tree[edge[0]].add(edge[1]);
            tree[edge[1]].add(edge[0]);
        }
        
        boolean[] visited = new boolean[n + 1];
        
        visited[0] = true;
        visited[1] = true;
        tree[1].add(0);
        
        Queue<Pair> q = new LinkedList<>();
        q.add(new Pair(1, 0, 1.0));
        
        while(!q.isEmpty()) {
            Pair p = q.poll();
            int curNode = p.node;
            int curTime = p.time;
            double curProb = p.prob;
            
            if(curNode == target) {
                if(curTime == t) return curProb;
                if(curTime > t) return 0;
                
                
                List<Integer> nbr = tree[curNode];
                boolean flag = false;
                for(int nb : nbr) {
                    if(!visited[nb]) {
                        flag = true;
                    }
                }
                return flag ?  0 : curProb; 
            }
            
            List<Integer> nbr = tree[curNode];
            double size = nbr.size() - 1;
            
            for(int nb : nbr) {
                if(!visited[nb]) {
                    visited[nb] = true;
                    q.add(new Pair(nb, curTime + 1, curProb * (1 / size)));
                }
            }
        }
        return -1;
    }
```
https://leetcode.com/problems/even-odd-tree/
```
    public boolean isEvenOddTree(TreeNode root) {
        if(root == null) return false;
        if(root.val % 2 == 0) return false;
        
        Queue<TreeNode> q = new LinkedList<>();
        q.add(root);
        
        int level = -1;
        while(!q.isEmpty()) {
            int size = q.size();
            
            level++;
            int oddDescreasing = Integer.MAX_VALUE;
            int oddIncreasing = Integer.MIN_VALUE;
            for(int i = 0; i < size; i++) {
                TreeNode node = q.poll();
                
                if(level % 2 == 0) {
                    if(node.val % 2 == 0) return false;
                    if(oddIncreasing < node.val) {
                        oddIncreasing = node.val;
                    } else {
                        return false;
                    }
                } else {
                    if(node.val % 2 == 1) return false;
                    if(oddDescreasing > node.val) {
                        oddDescreasing = node.val;
                    } else {
                        return false;
                    }
                }

                if(node.left != null) {
                    q.add(node.left);
                }
                if(node.right != null) {
                    q.add(node.right);
                }
            }
        }
        return true;
    }
```
https://leetcode.com/problems/binary-tree-level-order-traversal/
```
    public List<List<Integer>> levelOrder(TreeNode root) {
        
        List<List<Integer>> res = new ArrayList<>();
        if(root == null) return res;
        
        Queue<TreeNode> q = new LinkedList<>();
        q.add(root);
        while(!q.isEmpty()) {
            int size = q.size();
            List<Integer> mid = new ArrayList<>();
            
            for(int i = 0; i < size; i++) {
                TreeNode node = q.poll();
                
                mid.add(node.val);
                if(node.left != null) {
                    q.add(node.left);
                }
                
                if(node.right != null) {
                    q.add(node.right);
                }
            }
            res.add(mid);
        }
        return res;
    }
```

https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/
```
public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
       List<List<Integer>> res = new ArrayList<>();
        if(root == null) return res;
        
        Queue<TreeNode> q = new LinkedList<>();
        q.add(root);
        while(!q.isEmpty()) {
            int size = q.size();
            LinkedList<Integer> mid = new LinkedList<>();
            
            for(int i = 0; i < size; i++) {
                TreeNode node = q.poll();
                
                if(res.size() % 2 == 1) {
                    mid.addFirst(node.val);
                } else {
                    mid.add(node.val);
                }

                if(node.left != null) {
                    q.add(node.left);
                }
                
                if(node.right != null) {
                    q.add(node.right);
                }
            }
            res.add(mid);
        }
        return res;
    }
```
https://leetcode.com/problems/binary-tree-level-order-traversal-ii/
```
public List<List<Integer>> levelOrderBottom(TreeNode root) {
        List<List<Integer>> res = new ArrayList<>();
        if(root == null) return res;
        
        Queue<TreeNode> q = new LinkedList<>();
        q.add(root);
        while(!q.isEmpty()) {
            int size = q.size();
            List<Integer> mid = new ArrayList<>();
            
            for(int i = 0; i < size; i++) {
                TreeNode node = q.poll();
                
                mid.add(node.val);
                if(node.left != null) {
                    q.add(node.left);
                }
                
                if(node.right != null) {
                    q.add(node.right);
                }
            }
            res.add(mid);
        }
        Collections.reverse(res);
        return res;
    }
```

https://leetcode.com/problems/binary-tree-right-side-view/
```
public List<Integer> rightSideView(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if(root == null) return res;
        
        Queue<TreeNode> q = new LinkedList<>();
        q.add(root);
        while(!q.isEmpty()) {
            int size = q.size();
            List<Integer> mid = new ArrayList<>();
            
            for(int i = 0; i < size; i++) {
                TreeNode node = q.poll();
                
                if(i == size - 1) {
                    res.add(node.val);
                }
                
                if(node.left != null) {
                    q.add(node.left);
                }
                
                if(node.right != null) {
                    q.add(node.right);
                }
            }
        }
        return res;
    } 
```
https://leetcode.com/problems/n-ary-tree-level-order-traversal/
```
  public List<List<Integer>> levelOrder(Node root) {
      List<List<Integer>> res = new ArrayList<>();
      if(root == null) return res;
      
      Queue<Node> q = new LinkedList<>();
      q.add(root);
      while(!q.isEmpty()) {
          int size = q.size();
          List<Integer> mid = new ArrayList<>();
          
          for(int i = 0; i < size; i++) {
              Node node = q.poll();
              
              mid.add(node.val);
              if(node.children != null) {
                  for(Node child: node.children) {
                      q.add(child);
                  }
              }
          }
          res.add(mid);
      }
      return res;
  }
```

https://leetcode.com/problems/find-largest-value-in-each-tree-row/

```
public List<Integer> largestValues(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if(root == null) return res;
        
        Queue<TreeNode> q = new LinkedList<>();
        q.add(root);
        while(!q.isEmpty()) {
            int size = q.size();
            
            int max = Integer.MIN_VALUE;
            
            for(int i = 0; i < size; i++) {
                TreeNode node = q.poll();
                
                max = Math.max(max, node.val);
                if(node.left != null) {
                    q.add(node.left);
                }
                
                if(node.right != null) {
                    q.add(node.right);
                }
            }
            res.add(max);
        }
        return res;
    }
```
https://leetcode.com/problems/add-one-row-to-tree/
```
public TreeNode addOneRow(TreeNode root, int val, int depth) {
        if(root == null) return root;
        if(depth == 1) {
            TreeNode r = root;
            root = new TreeNode(val);
            root.left = r;
        }
        
        Queue<TreeNode> q = new LinkedList<>();
        q.add(root);
        int level = 1;
        while(!q.isEmpty()) {
            int size = q.size();
            level++;
            
            for(int i = 0; i < size; i++) {
                TreeNode node = q.poll();
                
                if(level == depth ) {
                    TreeNode curLeft = node.left;
                    node.left = new TreeNode(val);
                    node.left.left = curLeft;
                    
                    TreeNode curRight = node.right;
                    node.right = new TreeNode(val);
                    node.right.right = curRight;
                    if(i == size - 1) return root;
                } else {
                
                    if(node.left != null) {
                        q.add(node.left);
                    }

                    if(node.right != null) {
                        q.add(node.right);
                    }
                }
            }
        }
        return root;
    }
```
https://leetcode.com/problems/average-of-levels-in-binary-tree/
```
public List<Double> averageOfLevels(TreeNode root) {
        List<Double> res = new ArrayList<>();
        if(root == null) return res;
        
        Queue<TreeNode> q = new LinkedList<>();
        q.add(root);
        while(!q.isEmpty()) {
            int size = q.size();
            Double sum = 0.0;
            int count = 0;
            for(int i = 0; i < size; i++) {
                TreeNode node = q.poll();
                
                sum += node.val;
                count++;
                
                if(node.left != null) {
                    q.add(node.left);
                }
                
                if(node.right != null) {
                    q.add(node.right);
                }
            }
            res.add(sum/count);
        }
        return res;
    }
```
https://leetcode.com/problems/maximum-width-of-binary-tree/
```
public int widthOfBinaryTree(TreeNode root) {
        if(root == null) return 0;
        
        LinkedList<Pair<TreeNode, Integer>> q = new LinkedList<>();
        q.add(new Pair(root, 0));
        
        int maxWitdth = Integer.MIN_VALUE;
        
        while(!q.isEmpty()) {
            int size = q.size();
            int levelSize = 0;
            
            Pair<TreeNode, Integer> head = q.getFirst();
            
            for(int i = 0; i < size; i++) {
                Pair<TreeNode, Integer> p = q.poll();
                
                TreeNode node = p.getKey();
                levelSize = p.getValue();
                
                if(node.left != null){
                    q.add(new Pair(node.left, 2 * levelSize + 1));
                } 
                
                if(node.right != null) {
                    q.add(new Pair(node.right, 2 * levelSize + 2));
                }
            }
            
            maxWitdth = Math.max(maxWitdth, levelSize  - head.getValue() + 1);
        }
        return maxWitdth;
    }
```

#### Node deletion:

https://leetcode.com/problems/delete-nodes-and-return-forest/
```
public List<TreeNode> delNodes(TreeNode root, int[] to_delete) {
        List<TreeNode> res = new ArrayList<>();
        if(root == null) return res;
        
        res.add(root);
        
        Set<Integer> delSet = new HashSet<>();
        for(int i : to_delete) {
            delSet.add(i);
        }
        
        Queue<TreeNode> q = new LinkedList<>();
        q.add(root);
        
        while(!q.isEmpty()) {
            TreeNode node = q.poll();
            
            if (delSet.contains(node.val)) {
                res.remove(node);
                if (node.left != null) res.add(node.left);
                if (node.right != null) res.add(node.right);
            }
            
            if(node.left != null) {
                q.add(node.left);
                if(delSet.contains(node.left.val)) {
                    node.left = null;
                }
            }
            
            if(node.right != null) {
                q.add(node.right);
                if(delSet.contains(node.right.val)) {
                    node.right = null;
                }
            }
        }
        
        return res;
    }
```
https://leetcode.com/problems/delete-node-in-a-bst/
```
public TreeNode deleteRoot(TreeNode root) {
        if(root == null) return null;
        if(root.right == null) return root.left;
        TreeNode findLeftMost = root.right; // root.right should be the new root
        
        while(findLeftMost.left != null) {
            findLeftMost = findLeftMost.left; // find the left-most node
        }
        findLeftMost.left = root.left;
        return root.right;
    }
    
    public TreeNode deleteNode(TreeNode root, int key) {
        if(root == null || root.val == key) return  deleteRoot(root);
        
        TreeNode node = root;
        // search the node
        while(true) {
            if(node.val > key) {
                if(node.left == null || node.left.val == key) {
                    node.left = deleteRoot(node.left);
                    break;
                }
                
                node = node.left;
            } else {
                if(node.right == null || node.right.val == key){
                    node.right = deleteRoot(node.right);
                     break;
                }
                node = node.right;
            }
        }
        return root;
    }
```
https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/
```
public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {
        return dfs(preorder, 0, preorder.length - 1, postorder, 0, postorder.length - 1);
    }
    
    // pre = [1,2,4,5,3,6,7]
    // post = [4,5,2,6,7,3,1]
    // root = 1 -> left= [4,5,2], right = [6, 7, 3]
    //
    public TreeNode dfs(int[] pre, int preStart, int preEnd, int[] post, int postStart, int postEnd) {
        if(preStart > preEnd) return null;
        
        TreeNode root = new TreeNode(pre[preStart]);
        if(preStart == preEnd) return root;
        
        int postIndex = postStart;
        // divide postIndex by two half, leave last elemen since it is root.
        while(post[postIndex] != pre[preStart + 1]) postIndex++;
        
        // len of divide left and right subtrees.
        int len = postIndex - postStart + 1;
        
        root.left = dfs(pre, preStart + 1, preStart + len, post, postStart, postIndex);
        root.right = dfs(pre, preStart + len + 1, preEnd, post, postIndex + 1, preEnd - 1);
        return root;
    }
```
https://leetcode.com/problems/all-possible-full-binary-trees/
```
  public List<TreeNode> allPossibleFBT(int n) {
        List<TreeNode> res = new ArrayList<>();
        if(n == 0) return res;
        if(n == 1) {
            TreeNode root = new TreeNode(0);
            res.add(root);
            return res;
        }
        n = n - 1;
        // build from root to i (left) and n - i (right) 
        for(int i = 1; i < n; i += 2) {
            List<TreeNode> leftList = allPossibleFBT(i);
            List<TreeNode> rightList = allPossibleFBT(n - i);
            for(TreeNode left : leftList) {
                for(TreeNode right : rightList) {
                    TreeNode root = new TreeNode(0);
                    root.left = left;
                    root.right = right;
                    res.add(root);
                }
            }
        }
        return res;
    }
```
https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/
```
int index = 0;
    public TreeNode bstFromPreorder(int[] preorder) {
        return buildTree(preorder, Integer.MIN_VALUE, Integer.MAX_VALUE, preorder.length);
    }
    
    public TreeNode buildTree(int[] pre, int min, int max, int len) {
        if(index == len) return null;
        
        int val = pre[index];
        if(val < min || val > max) return null;
        
        index++;
        
        TreeNode root = new TreeNode(val);
        root.left = buildTree(pre, min, val, len);
        root.right = buildTree(pre, val, max, len);
        
        return root;
    }
```
https://leetcode.com/problems/recover-a-tree-from-preorder-traversal/
```
int index = 0;
    public TreeNode recoverFromPreorder(String traversal) {
        return buildTree(traversal, 0);
    }
    
    public TreeNode buildTree(String traversal, int depth) {
        int numDash = 0;
        
        while(index + numDash < traversal.length() && traversal.charAt(index + numDash) == '-') {
            numDash++;
        }
        
        if(numDash != depth) return null;
        
        int next = index + numDash;
        
        while(next < traversal.length() && traversal.charAt(next) != '-') {
            next++;
        }
        
        int val = Integer.parseInt(traversal.substring(index + numDash, next));
        index = next;
        
        TreeNode root = new TreeNode(val);
        root.left = buildTree(traversal, depth + 1);
        root.right = buildTree(traversal, depth + 1);
        return root;
    }
```
https://leetcode.com/problems/merge-bsts-to-create-single-bst/

```
public TreeNode canMerge(List<TreeNode> trees) {
        Map<Integer, TreeNode> treeDict = new HashMap<>();
        for(TreeNode tree: trees) {
            treeDict.put(tree.val, tree);
        }
        
        // merge Trees 
        for(TreeNode tree : trees) {
            if(treeDict.containsKey(tree.val)) {
                merge(tree, treeDict);
            }
        }
        
        // after megring all trees only one tree should be there in treeDIct
        
        if(treeDict.size() != 1) {
            return null;
        } else {
            for(Integer n : treeDict.keySet()) {
                if(isValidBST(treeDict.get(n), Integer.MIN_VALUE, Integer.MAX_VALUE)) {
                    return treeDict.get(n);
                } else {
                    return null;
                }
            }
        }
        return null;
    }
    
    
    public void merge(TreeNode root, Map<Integer, TreeNode> treeDict) {
        treeDict.remove(root.val);
        // merge left
        if(root.left != null && treeDict.containsKey(root.left.val)) {
            
            merge(treeDict.get(root.left.val), treeDict);
            
            root.left = treeDict.get(root.left.val);
            
            treeDict.remove(root.left.val);
        }
        
        // merge right
        if(root.right != null && treeDict.containsKey(root.right.val)) {
            
            merge(treeDict.get(root.right.val), treeDict);
            
            root.right = treeDict.get(root.right.val);
            
            treeDict.remove(root.right.val);
        }
        // add it back
        treeDict.put(root.val, root);
    }

    public boolean isValidBST(TreeNode root, int min, int max) {
        if(root == null) return true;
        if(root.val <= min || root.val >= max) return false;
        return isValidBST(root.left, min, root.val) && isValidBST(root.right, root.val, max);
    }
```
https://leetcode.com/problems/unique-binary-search-trees-ii/
```
public List<TreeNode> generateTrees(int start, int end) {
        List<TreeNode> allTrees = new ArrayList<>();
        if(start > end) {
            allTrees.add(null);
            return allTrees;
        }
        
        for(int i = start; i <= end; i++) {
            // all possible left subtrees if i is choosen to be a root
            List<TreeNode> allLeftTrees = generateTrees(start, i - 1);
            
            // all possible right subtrees if i is choosen to be a root
            List<TreeNode> allRightTrees = generateTrees(i + 1, end);
            
            // connect left and right trees to the root i
            for(TreeNode left : allLeftTrees ){
                for(TreeNode right : allRightTrees) {
                    TreeNode node = new TreeNode(i);
                    node.left = left;
                    node.right = right;
                    allTrees.add(node);
                }
            }
        }
        return allTrees;
    }
    public List<TreeNode> generateTrees(int n) {
        if(n == 0) return null;
        return generateTrees(1, n);
    }
```
https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/
```
ListNode head;
    
    public int findSize(ListNode node) {
        
        ListNode cur = node;
        int count = 0;
        
        while(cur != null) {
            cur = cur.next;
            count++;
        }
        return count;
    }
    
    public TreeNode sortedListToBST(int left, int right) {
        if(left > right) {
            return null;
        }
        
        int mid = (left + right) / 2;
        
        TreeNode leftNode = sortedListToBST(left, mid - 1);
        
        TreeNode root = new TreeNode(this.head.val);
        
        root.left = leftNode;
        this.head = this.head.next;
        
        root.right = sortedListToBST(mid + 1, right);
        
        return root;
    }
    public TreeNode sortedListToBST(ListNode head) {
        int size = findSize(head);
        
        this.head = head;
        
        return sortedListToBST(0, size - 1);
    }
```
https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/
```
public TreeNode sortedArrayToBST(int[] nums, int left, int right) {
        if(left > right) {
            return null;
        }
        
        int mid = (left + right) / 2;
        
        TreeNode root = new TreeNode(nums[mid]);
        root.left = sortedArrayToBST(nums, left, mid - 1);
        root.right = sortedArrayToBST(nums, mid + 1, right);
        return root;
        
    }
    public TreeNode sortedArrayToBST(int[] nums) {
        return sortedArrayToBST(nums, 0, nums.length - 1);
    }
```


#### Distance between two Nodes:
https://leetcode.com/problems/minimum-distance-between-bst-nodes/
```
Integer prev, min;
    public int minDiffInBST(TreeNode root) {
        prev = null;
        min = Integer.MAX_VALUE;
        findMin(root);
        return min;
    }
    
    public void findMin(TreeNode root) {
        if(root == null) return;
        findMin(root.left);
        if(prev != null) {
            min = Math.min(min, root.val - prev);
        }
        prev = root.val;
        findMin(root.right);
    }
```
https://leetcode.com/problems/sum-of-distances-in-tree/
```
List<Set<Integer>> graph;
    int[] ans;
    int[] count;
    int N;
    public int[] sumOfDistancesInTree(int n, int[][] edges) {
        ans = new int[n];
        count = new int[n];
        graph = new ArrayList<>();
        N = n;
        Arrays.fill(count, 1);
        
        for(int i = 0; i < n; i++) {
            graph.add(new HashSet<>());
        }
        for(int[] edge: edges) {
            graph.get(edge[0]).add(edge[1]);
            graph.get(edge[1]).add(edge[0]);
        }
        dfs(0, -1);
        dfs2(0, -1);
        return ans;
    }
    
    public void dfs(int node, int parent) {
        for(int child : graph.get(node)) {
            if(child != parent) {
                dfs(child, node);
                count[node] += count[child];
                ans[node] += ans[child] + count[child];
            }
        }
    }
    
    public void dfs2(int node, int parent) {
        for(int child : graph.get(node)) {
            if(child != parent) {
                ans[child] = ans[node] - count[child] + N - count[child];
                dfs2(child, node);
            }
        }
    }
```
https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/
```
Map<TreeNode, TreeNode> parentDict = new HashMap<>();
    public List<Integer> distanceK(TreeNode root, TreeNode target, int k) {
        List<Integer> res = new ArrayList<>();
        if(root == null) return res;
        
        buildParentDict(root, null);
        
        Queue<TreeNode> q = new LinkedList<>();
        q.add(null);
        q.add(target);
        
        Set<TreeNode> seen = new HashSet<>();
        seen.add(target);
        seen.add(null);
        
        int dist = 0;
        
        while(!q.isEmpty()) {
            TreeNode node = q.poll();
            if(node == null) {
                if(dist == k) {
                    for(TreeNode n : q) {
                        res.add(n.val);
                    }
                    return res;
                }
                dist++;
                q.add(null);
            } else {
                if(!seen.contains(node.left)) {
                    seen.add(node.left);
                    q.add(node.left);
                }
                
                if(!seen.contains(node.right)) {
                    seen.add(node.right);
                    q.add(node.right);
                }    
                
                TreeNode parent = parentDict.get(node);
                if(!seen.contains(parent)) {
                    seen.add(parent);
                    q.add(parent);
                }
            }
        }
        return res;
        
    }
    
    public void buildParentDict(TreeNode node, TreeNode parent) {
        if(node != null) {
            parentDict.put(node, parent);
            buildParentDict(node.left, node);
            buildParentDict(node.right, node);
        }
    }
```

#### Inorder traversal:
https://leetcode.com/problems/increasing-order-search-tree/
```
public TreeNode increasingBST(TreeNode root) {
        if(root == null) return root;
        
        List<Integer> vals = new ArrayList<>();
        inOrder(root, vals);
        TreeNode node = new TreeNode(0);
        TreeNode cur = node;
        for(int i : vals) {
            cur.right = new TreeNode(i);
            cur = cur.right;
        }
        return node.right;
    }
    
    public void inOrder(TreeNode root, List<Integer> vals) {
        if(root != null) {
            inOrder(root.left, vals);
            vals.add(root.val);
            inOrder(root.right, vals);
        }
    }
```
https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/
```
int sum = 0;
    public TreeNode bstToGst(TreeNode root) {
        inOrder(root);
        return root;
    }
    
    public void inOrder(TreeNode root) {
        if(root != null) {
            inOrder(root.right);
            sum += root.val;
            root.val = sum;
            inOrder(root.left);
        }
    }
```
https://leetcode.com/problems/all-elements-in-two-binary-search-trees/
```
public List<Integer> getAllElements(TreeNode root1, TreeNode root2) {
        List<Integer> res = new ArrayList<>();
        if(root1 == null && root2 == null) return res;
        Stack<TreeNode> s1 = new Stack<>();
        Stack<TreeNode> s2 = new Stack<>();
        
        while( root1 != null || root2 != null || !s1.isEmpty() || !s2.isEmpty()) {
            while(root1 != null) {
                s1.push(root1);
                root1 = root1.left;
            }
            
            while(root2 != null) {
                s2.push(root2);
                root2 = root2.left;
            }
            
            if(s2.isEmpty() || !s1.isEmpty() && s1.peek().val <= s2.peek().val) {
                TreeNode node = s1.pop();
                res.add(node.val);
                root1 = node.right;
            } else {
                TreeNode node = s2.pop();
                res.add(node.val);
                root2 = node.right;
            }
        }
        return res;
    }
```
https://leetcode.com/problems/validate-binary-search-tree/
```
 public boolean isValidBST(TreeNode root) {
        return isValidBST(root, null, null);
    }
    
    public boolean isValidBST(TreeNode root, Integer min, Integer max) {
        if(root == null) return true;
        if((min != null && root.val <= min) || (max != null && root.val >= max)) return false;
        return isValidBST(root.left, min, root.val) && isValidBST(root.right, root.val, max);
    }
```
https://leetcode.com/problems/convert-bst-to-greater-tree/
```
int sum = 0;
    public TreeNode convertBST(TreeNode root) {
        inOrder(root);
        return root;
    }
    
   public void inOrder(TreeNode root) {
        if(root != null) {
            inOrder(root.right);
            sum += root.val;
            root.val = sum;
            inOrder(root.left);
        }
    }
```
https://leetcode.com/problems/range-sum-of-bst/
```
public int rangeSumBST(TreeNode root, int low, int high) {
        if(root == null) return 0;
        
        Queue<TreeNode> q = new LinkedList<>();
        q.add(root);
        int sum = 0;
        
        while(!q.isEmpty()) {
            TreeNode node = q.poll();
            
            if(node.val >= low && node.val <= high) {
                sum += node.val;
            }
            
            if(node.left != null) q.add(node.left);
            if(node.right != null) q.add(node.right);
        }
        return sum;
    }
```
#### Flipping:
https://leetcode.com/problems/flip-equivalent-binary-trees/
```
public boolean flipEquiv(TreeNode root1, TreeNode root2) {
        List<Integer> vals1 = new ArrayList<>();
        List<Integer> vals2 = new ArrayList<>();
        dfs(root1, vals1);
        dfs(root2, vals2);
        return vals1.equals(vals2);
    }
    
    public void dfs(TreeNode root, List<Integer> vals) {
        if(root != null) {
            vals.add(root.val);
            int left = root.left != null ? root.left.val : -1;
            int right = root.right != null ? root.right.val : -1;
            
            if(left < right) {
                dfs(root.left, vals);
                dfs(root.right, vals);
            } else {
                dfs(root.right, vals);
                dfs(root.left, vals);
            }
            vals.add(null);
        }
    }
```
https://leetcode.com/problems/flip-binary-tree-to-match-preorder-traversal/
```
int index = 0;
    public List<Integer> flipMatchVoyage(TreeNode root, int[] voyage) {
        List<Integer> list = new ArrayList<>();
        if(root == null) return list;
        dfs(root, list, voyage);
        if(!list.isEmpty() && list.get(0) == -1) {
            list.clear();
            list.add(-1);
        }
        return list;
    }
    
    public void dfs(TreeNode root, List<Integer> list, int[] voyage) {
        if(root != null) {
            if(root.val != voyage[index++]) {
                list.clear();
                list.add(-1);
                return;
            }
            
            if(index < voyage.length && root.left != null && root.left.val != voyage[index]){
                list.add(root.val);
                dfs(root.right, list, voyage);
                dfs(root.left, list, voyage);
            } else {
                dfs(root.left, list, voyage);
                dfs(root.right, list, voyage);
            }
        }
    }
```
https://leetcode.com/problems/check-completeness-of-a-binary-tree/
```
public boolean isCompleteTree(TreeNode root) {
        if(root == null) return false;
        Queue<TreeNode> q = new LinkedList<>();
        q.add(root);
        
        boolean end = false;
        while(!q.isEmpty()) {
            TreeNode node = q.poll();
            if(node == null) {
                end = true;
            } else {
                if(end) return false;
                q.add(node.left);
                q.add(node.right);
            }
        }
        return true;
    }
```
https://leetcode.com/problems/univalued-binary-tree/
```
    public boolean isUnivalTree(TreeNode root) {
       return isUnival(root, root.val);
    }
    
    public boolean isUnival(TreeNode root, int val) {
        if(root == null) return true;
        if(root.val != val) {
            return false;
        }
        return isUnival(root.left, val)  && isUnival(root.right, val);
    }
```
#### Counting of nodes:
https://leetcode.com/problems/cousins-in-binary-tree/
```
public boolean isCousins(TreeNode root, int x, int y) {
        if(root == null) return false;
        
        Queue<TreeNode> q = new LinkedList<>();
        q.add(root);
        while(!q.isEmpty()){
            int size = q.size();
            
            List<Integer> res = new ArrayList<>();
            for(int i = 0; i < size; i++) {
                TreeNode node = q.poll();
                
                res.add(node.val);
                
                if(node.left != null) {
                    q.add(node.left);
                }
                
                if(node.right != null) {
                    q.add(node.right);
                }
                
                if(node.left != null && node.right != null) {
                    
                    if((node.left.val == x || node.left.val == y) && (node.right.val == x || node.right.val == y)) {
                       return false;
                    }
                }
            }
            
            if(res.contains(x) && res.contains(y)) {
                return true;
            }
        }
        return false;
    }
```
https://leetcode.com/problems/count-good-nodes-in-binary-tree/
```
int goodNodes = 0;
    public int goodNodes(TreeNode root) {
        goodNode(root, Integer.MIN_VALUE);
        return goodNodes;
    }
    
    
    public void goodNode(TreeNode node, int max) {
        if(max <= node.val) {
            goodNodes++;
        }
        max = Math.max(node.val, max);
        if(node.right != null)
            goodNode(node.right, max);
        if(node.left != null)
            goodNode(node.left, max);

    }
```
https://leetcode.com/problems/number-of-nodes-in-the-sub-tree-with-the-same-label/
```
public int[] countSubTrees(int n, int[][] edges, String labels) {
        int[] ans = new int[labels.length()];
        if(edges.length == 0) return ans;
        
        List<List<Integer>> graph = new ArrayList();
        for(int i = 0; i < labels.length(); i++) {
            graph.add(new ArrayList<>());
        }
        
        for(int[] edge : edges) {
            graph.get(edge[0]).add(edge[1]);
            graph.get(edge[1]).add(edge[0]);
        }
        
        boolean[] visited = new boolean[labels.length()];
        visited[0] = true;
        dfs(0, ans, graph, visited, labels.toCharArray());
        return ans;
    }
    
    public int[] dfs(int index, int[] ans, List<List<Integer>> graph, boolean[] visited, char[] lab) {
        int[] counter = new int[128];
        char curChar = lab[index];
        counter[curChar]++;
        ans[index] = counter[curChar];
        
        
        for(Integer edge : graph.get(index)) {
            if(visited[edge]) continue;
            visited[edge] = true;
            int[] nextCounter = dfs(edge, ans, graph, visited, lab);
            for(int i = 0; i < 128; i++) {
                counter[i] += nextCounter[i];
            }
        }
        
        ans[index] = counter[curChar];
        return counter;
    }
```
https://leetcode.com/problems/number-of-good-leaf-nodes-pairs/

```
public int countPairs(TreeNode root, int distance) {
        Map<TreeNode, List<TreeNode>> map = new HashMap<>();
        List<TreeNode> leaves = new ArrayList<>();
        int res = 0;
        dfs(root, new ArrayList<>(), leaves, map);
        
        for(int i = 0; i < leaves.size(); i++) {
            for(int j = i + 1; j < leaves.size(); j++) {
                List<TreeNode> list1 = map.get(leaves.get(i));
                List<TreeNode> list2 = map.get(leaves.get(j));
                for(int k = 0; k < Math.min(list1.size(), list2.size()); k++) {
                    if(list1.get(k) != list2.get(k)) {
                        int dist = list1.size() - k + list2.size() - k;
                        if(dist <= distance) res++;
                        break;
                    }
                }
            }
        }
        return res;
        
    }
    
    public void dfs(TreeNode root, List<TreeNode> trail, List<TreeNode> leaves, Map<TreeNode, List<TreeNode>> map) {
        if(root == null) return;
        List<TreeNode> tmp = new ArrayList<>(trail);
        tmp.add(root);
        if(root.left == null && root.right == null) {
            leaves.add(root);
            map.put(root, tmp);
            return;
        }
        dfs(root.left, tmp, leaves, map);
        dfs(root.right, tmp, leaves, map);
    }
```
#### Recovery:
https://leetcode.com/problems/recover-binary-search-tree/
```
public void swap(TreeNode a, TreeNode b) {
        int tmp = a.val;
        a.val = b.val;
        b.val = tmp;
    }
    public void recoverTree(TreeNode root) {
        if(root == null) return;
        
        TreeNode x = null, y = null, pred = null, predecessor = null;
        
        while(root != null) {
            if(root.left != null) {
                
                predecessor = root.left;
                while(predecessor.right != null && predecessor.right != root) {
                    predecessor = predecessor.right;
                }
                
                if(predecessor.right == null) {
                    predecessor.right = root;
                    root = root.left;
                } else {
                    if(pred != null && root.val < pred.val) {
                        y = root;
                        if(x == null) x = pred;
                    }
                    
                    pred = root;
                    
                    predecessor.right = null;
                    root = root.right;
                }
                
            } else {
               if(pred != null && root.val < pred.val) {
                    y = root;
                    if(x == null) x = pred;
                }

                pred = root;
                root = root.right;
                
            }
        }
        swap(x, y);
    }
```
#### Kth smallest :
https://leetcode.com/problems/kth-smallest-element-in-a-bst/
```
public int kthSmallest(TreeNode root, int k) {        
        int n = getCount(root.left);
        
        if(n + 1 == k) return root.val;
        
        if(n + 1 < k) {
            return kthSmallest(root.right, k - n - 1);
        } else {
            return kthSmallest(root.left, k);
        }
    }
    
    public int getCount(TreeNode root) {
        if(root == null) return 0;
        return getCount(root.left) + getCount(root.right) + 1;
    }
```

https://leetcode.com/problems/largest-bst-subtree/
```
class Node {
        int min;
        int max;
        int count;
        public Node(int min, int max, int count) {
            this.min = min;
            this.max = max;
            this.count = count;
        }
    }
    
    Integer max = 0;
    public int largestBSTSubtree(TreeNode root) {
        largestBSt(root);
        return max;
    }
    
    public Node largestBSt(TreeNode cur) {
        // base case
        if(cur == null) return new Node(Integer.MAX_VALUE, Integer.MIN_VALUE, 0);
        // check if both left and right is bST
        Node left = largestBSt(cur.left);
        Node right = largestBSt(cur.right);
        
        // if either on is not BST return;
        if(left.count == -1 || right.count == -1) {
            return new Node(0, 0, -1);
        }
        
        // check if current node first with min max requirements
        if(cur.val <= left.max || cur.val >= right.min) {
            return new Node(0, 0, -1);
        }
        
        // if cur node reaches here it is BST
        int count = left.count + right.count + 1;
        max = Math.max(max, count);
        
        return new Node(left.min == Integer.MAX_VALUE ? cur.val : left.min,
        right.max == Integer.MIN_VALUE ? cur.val : right.max, count);
    }
```
https://leetcode.com/problems/kth-largest-element-in-a-stream/
```
TreeNode root;
    int k;
    
    public KthLargest(int k, int[] nums) {
        this.k = k;
        for(int i : nums) {
            root = add(root, i);
        }
    }
    
    public int add(int val) {
        root = add(root, val);
        int count = this.k;
        
        TreeNode walker = root;
        while(count > 0) {
            int pos = (walker.right != null ? walker.right.count : 0) + 1;
            
            if(count == pos) break;
            
            if(count > pos) {
                count -= pos;
                walker = walker.left;
            } else if (count < pos) {
                walker = walker.right;
            }
        }
        return walker.val;
    }
    
    public TreeNode add(TreeNode root, int val) {
        if(root == null) return new TreeNode(val);
        root.count++;
        if(val < root.val) {
            root.left = add(root.left, val);
        } else {
            root.right = add(root.right, val);
        }
        return root;
    }
    
    class TreeNode {
        int val, count = 1;
        TreeNode left, right;
        TreeNode(int val) {
            this.val = val;
        }
    }
```
#### Trimming or pruning:
https://leetcode.com/problems/trim-a-binary-search-tree/

```
public TreeNode trimBST(TreeNode root, int low, int high) {
        if(root == null) return root;
        // ignore left and irght based on low and high
        if(root.val < low) return trimBST(root.right, low, high);
        if(root.val > high) return trimBST(root.left, low, high);
        
        // check for remaing in bottom
        root.left = trimBST(root.left, low, high);
        root.right = trimBST(root.right, low, high);
        return root;
    }
```
#### Searching:

https://leetcode.com/problems/search-in-a-binary-search-tree/
```
    public TreeNode searchBST(TreeNode root, int val) {
        if(root == null) {
            return root;
        } else {
            if(root.val == val) return root;
            if(root.val < val) return searchBST(root.right, val);
            if(root.val > val) return searchBST(root.left, val);
        }
        return null;
    }
```

#### Tree checking:
https://leetcode.com/problems/same-tree/
```
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if(p == null && q == null) return true;
        if(q == null || p == null) return false;
        if(q.val != p.val) return false;
        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
    }
```
https://leetcode.com/problems/symmetric-tree/
```
    public boolean isSymmetric(TreeNode root) {
        if(root == null) return false;
        return isSameTree(root.left, root.right);
    }
    
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if(p == null && q == null) return true;
        if(p == null || q == null) return false;
        if(p.val != q.val) return false;
        return isSameTree(p.left, q.right) && isSameTree(p.right, q.left);
    } 
```

#### Depth problem:
https://leetcode.com/problems/maximum-depth-of-binary-tree/
```
    public int maxDepth(TreeNode root) {
        if(root == null) return 0;
        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
    }
```
https://leetcode.com/problems/minimum-depth-of-binary-tree/
```
public int minDepth(TreeNode root) {
        if(root == null) return 0;
        
        if(root.left == null && root.right == null) return 1;
        
        int minDepth = Integer.MAX_VALUE;
        
        if(root.left != null) {
            minDepth = Math.min(minDepth(root.left), minDepth);
        }
        if(root.right != null) {
            minDepth = Math.min(minDepth(root.right), minDepth);
        }
        return minDepth + 1;
    }
```
https://leetcode.com/problems/minimum-absolute-difference-in-bst/
```
    int min = Integer.MAX_VALUE;
    TreeNode prev = null;
    public int getMinimumDifference(TreeNode root) {
        inOrderTraversal(root);
        return min;
    }
    public void inOrderTraversal(TreeNode root) {
        if(root == null) return;
        
        inOrderTraversal(root.left);
        
        if(prev != null) {
            min = Math.min(min , root.val - prev.val);
        }
        
        prev = root;
        inOrderTraversal(root.right);
    }
```
https://leetcode.com/problems/maximum-depth-of-n-ary-tree/
```
    int max = Integer.MIN_VALUE;
    public int maxDepth(Node root) {
        if(root == null) return 0;
        if(root.children.isEmpty()) return 1;
        List<Integer> hieghts = new ArrayList<>();
        for(Node node : root.children) {
           hieghts.add(maxDepth(node));
        }
        return Collections.max(hieghts) + 1;
    }
```


